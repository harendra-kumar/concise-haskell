Template Haskell
================

.. contents:: Table of Contents
   :depth: 1

Terminology
-----------

+------------------------+----------------------------------------------------+
| TH                     | Template Haskell                                   |
+------------------------+----------------------------------------------------+

What is it?
-----------

Template Haskell allows us to do compile-time meta-programming in Haskell. A
template Haskell macro or splice is a (template) Haskell code which is used to
generate some Haskell source at compile time. Template Haskell functions or
values can be called or spliced in the host program source. Just like macro
pre-processing, in a pre-compile phase the template Haskell code is first
compiled and then run in the context of the hosting source (at the splice
point) to generate the desired Haskell source. The generated Haskell source is
then spliced with the host program source and the combined Haskell program is
then compiled.

As a trivial example, the expression ``5 + 1`` can be evaluated and replaced by
``6`` at compile time. Arbitrary Haskell source code can be represented and
produced by template haskell. We can examine and use information about the
hosting source to expand the splice. We can even perform IO to gather
information to generate the source.

Template Haskell does a job similar to what macros would do in C. However, it
is much more powerful and the template Haskell code is statically type checked
and it of course generates Haskell code which is staically type checked.

Example
-------

Abstract Syntax Splicing
------------------------

A programming language consists of a concrete syntax and an abstract syntax.
Concrete syntax is what the programmer writes. Abstract syntax is a
representation of the program itself as a data structure.  It is represented as
a tree data structure (Abstract Syntax Tree or AST) with each node representing
a specific construct in the concrete syntax. The abstract syntax tree in
Haskell is basically an ADT representing the syntax tree.

A template Haskell expression (splice) is first compiled and then run to
evaluate it to Haskell's abstract syntax and the resulting AST entity is
spliced with the AST of the source program at the specified splice point.

AST Splices Generated by TH
---------------------------

The following list represents the constructs needed to represent the Haskell
AST. We can generate programmatically using TH and then splice them back in the
source program.  These constructs in fact cover everything in any Haskell
program source! Each construct is represented by a Haskell algebraic data type
(ADT).

+-----------+-----------------------------------------------------------------+
| Haskell   | Description                                                     |
| ADT       |                                                                 |
+===========+=================================================================+
| Type      | Represents a type declaration in Haskell source                 |
|           | (e.g. ``x :: Int``)                                             |
+-----------+-----------------------------------------------------------------+
| Dec       | Represents a top level declaration (e.g. ``f x = x * x``)       |
+-----------+-----------------------------------------------------------------+
| Exp       | An expression (e.g. ``x * x``)                                  |
+-----------+-----------------------------------------------------------------+
| Pat       | A pattern                                                       |
+-----------+-----------------------------------------------------------------+

The `Language.Haskell.TH` module from the `template-haskell` package provides
algebraic data types to represent these entities.  TBD - provide hyperlinks.

TBD: Typed expression?

TBD: introduce this in the basic syntax chapter. The `Language.Haskell.TH`
module can also act as a guide to the syntax.

Generating the AST Splices
--------------------------

The Q Monad
~~~~~~~~~~~

The `Q` (for Quote) monad allows us to compose a TH splice representing an AST
data type by querying the host source code, source location, report errors, and
even perform IO to get information for creating the splice. The final output is
one of the AST entities that we described in the previous section.

  runQ :: Quasi m => Q a -> m a

Representing The AST
~~~~~~~~~~~~~~~~~~~~

The Q monad is used to compose and return a TH splice having one of the
following types:

+--------------+--------------------------------------------------------------+
| Splice Type  | Represents an AST construct for                              |
+==============+==============================================================+
| Q Exp        | An expression                                                |
+--------------+--------------------------------------------------------------+
| Q (TExp a)   | A typed expression                                           |
+--------------+--------------------------------------------------------------+
| Q Pat        | A pattern                                                    |
+--------------+--------------------------------------------------------------+
| Q Type       | A type                                                       |
+--------------+--------------------------------------------------------------+
| Q [Dec]      | A list of declarations at top level                          |
+--------------+--------------------------------------------------------------+

These data types (also known as splices) are the interface between template
haskell and the Haskell source where they are spliced in. For example, a splice
of type ``Q Exp`` can be used wherever we can use an expression in the Haskell
source.

Splices are in turn constructed using various AST data constructors described
in the `template-haskell` package.  Note that a splice is merely an ordinary
Haskell algebraic data type, it can be passed around in functions, can be used
as input to generate other splices.

See Where can they occur? for using partial type signatures in quotations.

Splicing the AST
----------------

An AST data type returned by the Q monad can be spliced at an appropriate point
in the Haskell source. The splicing acts as if the equivalent Haskell source
was written at that point. The source context uniquely determines the type of
the splice that can be used in that context. For example ``f = $x`` requires
the splice ``x`` to be of type ``Q Exp`` because it is being used in an
expression context.

+-----------------------------------------------------------------------------+
| `-XTemplateHaskell`: Enable Template Haskell’s splice and quotation syntax. |
+-----------------------------------------------------------------------------+
| A symbol or expression representing a Haskell AST of type ``Q Exp``,        |
| ``Q Type``, ``Q [Dec]`` or ``Q Pat`` is spliced in the Haskell source       |
| (at compile time) using the TH splicing syntax.                             |
+-----------+-----------------------------------------------------------------+
| $x        | Expand an identifier `x` representing a TH splice               |
+-----------+-----------------------------------------------------------------+
| $(expr)   | Expand an expression `expr` representing a TH splice            |
+-----------+-----------------------------------------------------------------+
| A typed expression splice of type ``Q (TExp a)``                            |
+-----------+-----------------------------------------------------------------+
| $$x       | Expand an identifier representing a typed expression splice     |
+-----------+-----------------------------------------------------------------+
| $$(expr)  | Expand an expression representing a typed expression splice     |
+-----------+-----------------------------------------------------------------+
| `x` and `expr` can only use imported TH splices, and not splices defined    |
| elsewhere within the same module.                                           |
+-----------------------------------------------------------------------------+
| Declaration splices are not allowed anywhere except at top level.           |
+-----------------------------------------------------------------------------+

You may omit the $(...) in a top-level declaration splice. Simply writing an
expression (rather than a declaration) implies a splice. For example, you can
write::

  module Foo where
  import Bar

  f x = x

  $(deriveStuff 'f)   -- Uses the $(...) notation

  g y = y+1

  deriveStuff 'g      -- Omits the $(...)

  h z = z-1

Constructing AST Splices from Primitives
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using the Q monad and the TH lib functions::

  f = $(do
    nm1 <- newName "x"
    let nm2 = mkName "x"
    return (LamE [VarP nm1] (LamE [VarP nm2] (VarE nm1)))
   )
  will produce the splice

  f = \x0 -> \x -> x0

Generating AST Splices by Quoting Haskell Source
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The compiler provides a built-in quotation syntax using Oxford brackets to
`quote` Haskell source.  The result of the quoted Haskell source is an AST
splice (e.g. ``Q Exp``) corresponding to the quoted source. This can be used to
create splices more conveniently instead of building them with the raw AST
primitives.

+-----------------------------------------------------------------------------+
| `-XTemplateHaskellQuotes`: Enable only Template Haskell’s quotation syntax. |
+---------------------------------------+-------------------------------------+
| [| <expression> \|]                   | Q Exp                               |
+---------------------------------------+                                     |
| [e| <expression> \|]                  |                                     |
+---------------------------------------+-------------------------------------+
| [|| <typed expression> \||]           | Q (TExp a)                          |
+---------------------------------------+                                     |
| [e|| <typed expression> \||]          |                                     |
+---------------------------------------+-------------------------------------+
| [d| <list of declarations> \|]        | Q [Dec]                             |
+---------------------------------------+-------------------------------------+
| [t| <type signature> \|]              | Q Type                              |
+---------------------------------------+-------------------------------------+
| [p| <pattern> \|]                     | Q Pat                               |
+---------------------------------------+-------------------------------------+
| [varid| <an arbitrary string> \|]     | Quasi quotation                     |
+---------------------------------------+-------------------------------------+

Values of type ``TExp a`` may be converted to values of type ``Exp`` using the
function ``unType :: TExp a -> Exp``.

Since we have plain Haskell inside the quotes we can even use splices (e.g.
varE and mkName in the example below) inside the quotes.

::

  f = [| pi + $(varE (mkName "pi")) |]
  ...
  g = let pi = 3 in $f

  In this case, g is desugared to

  g = Prelude.pi + 3

Note that quotations are just splices i.e. values of type Q Exp, Q Dec etc.
They can be used wherever we can use those types. For example we can use
quotations inside the Q monad::

  f = "global"
  g = $( do
           Just nm <- lookupValueName "f"
           [| let f = "local" in $( varE nm ) |]

Defining Splices
----------------

Variable Name Capture
~~~~~~~~~~~~~~~~~~~~~

An occurrence of a variable named `x` is said to capture another ocurrence of
the same name `x` in its scope if both of them are referring to the same value.
For example::

  f x = x -- the variable x here is captured by the argument of f

Names & Scoping
~~~~~~~~~~~~~~~

AST constructs can refer to names of functions, data constructors or types etc.
A name is represented in the AST by the ``Name`` data type.  Names can be used
to construct Template Haskell expressions, patterns, declarations etc.  The
reify function can be used to lookup information about a name.

A name can refer to:

* A name currently in scope in the code where the splice is defined
* A name in scope where the splice is used (spliced)
* A local name constructed within the splice

Names can be
constructed in several ways, which come with different name-capture guarantees
(see Language.Haskell.TH.Syntax for an explanation of name capture). These

+-----------------------------------------------------------------------------+
| Referring to names currently in scope.                                      |
+--------------------+-----+--------------------------------------------------+
| Expression context | 'f  | Refers to the function ``f``                     |
|                    +-----+--------------------------------------------------+
|                    | 'C  | Refers to the data constructor ``C``             |
+--------------------+-----+--------------------------------------------------+
| Type context       | ''T | Refers to the type constructor ``T``             |
+--------------------+-----+--------------------------------------------------+
| These names can never be captured.                                          |
+-----------------------------------------------------------------------------+
| A name whose second character is a single quote (sadly) cannot be quoted in |
| this way. For example, if the function is called f'7, an attempt to quote   |
| it as 'f'7 would be parsed as the character literal 'f' followed by the     |
| numeric literal 7.                                                          |
+-----------------------------------------------------------------------------+

* lookupValueName and lookupTypeName are similar to 'f and ''T respectively,
  but the Names are looked up at the point where the current splice is being
  run. These names can never be captured.

* newName monadically generates a new name, which can never be captured.
* mkName generates a capturable name.
* Names constructed using newName and mkName may be used in bindings (such as
  let x = ... or x -> ...), but names constructed using lookupValueName,
  lookupTypeName, 'f, ''T may not.

Querying Names
~~~~~~~~~~~~~~

* reify
* reifyModule
* thisModule

Splice Functions
~~~~~~~~~~~~~~~~

A splice can be defined as a function and the arguments of the function can be
used to parameterise the splice.

+-----------------------------------------------------------------------------+
| Template Haskell functions (compile time macros with arguments)             |
+-----------------------------------+-----------------------------------------+
| ::                                | ::                                      |
|                                   |                                         |
|  module Bar where                 |  module Foo where                       |
|                                   |                                         |
|  import Language.Haskell.TH       |  import Bar                             |
|                                   |                                         |
|  add1 :: Int -> Q Exp             |  two :: Int                             |
|  add1 x = [| x + 1 \|]            |  two = $(add1 1)                        |
+-----------------------------------+-----------------------------------------+

Template Haskell cannot know what the argument to add1 will be at the
function’s definition site, so a lifting mechanism is used to promote x into a
value of type Q Exp. This functionality is exposed to the user as the Lift
typeclass in the Language.Haskell.TH.Syntax module. If a type has a Lift
instance, then any of its values can be lifted to a Template Haskell
expression::

  class Lift t where
      lift :: t -> Q Exp

In general, if GHC sees an expression within Oxford brackets (e.g., [| foo bar
\|], then GHC looks up each name within the brackets. If a name is global (e.g.,
suppose foo comes from an import or a top-level declaration), then the fully
qualified name is used directly in the quotation. If the name is local (e.g.,
suppose bar is bound locally in the function definition mkFoo bar = [| foo bar
\|]), then GHC uses lift on it (so GHC pretends [| foo bar \|] actually contains
[| foo $(lift bar) \|]). Local names, which are not in scope at splice
locations, are actually evaluated when the quotation is processed.

The template-haskell library provides Lift instances for many common data
types. Furthermore, it is possible to derive Lift instances automatically by
using the -XDeriveLift language extension. See Deriving Lift instances for more
information.

TH Lib Functions
----------------

Constructors
~~~~~~~~~~~~

+-------+--------+------------------------------------------------------------+
| Type  | Suffix | Constructor examples                                       |
+=======+========+============================================================+
| Exp   | E      | varE, conE, LitE, LamE                                     |
+-------+--------+------------------------------------------------------------+
| Pat   | P      | varP, conP, LitP                                           |
+-------+--------+------------------------------------------------------------+
| Type  | T      | varT, conT, LitT                                           |
+-------+--------+------------------------------------------------------------+
| Dec   | D      | FunD, ValD, DataD                                          |
+-------+--------+------------------------------------------------------------+

Functions
~~~~~~~~~

Conventions: returning type `Q Exp` end with `E` and so on.

References
----------

* https://www.schoolofhaskell.com/user/edwardk/bound
