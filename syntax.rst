Syntax in a nutshell
====================

* https://www.haskell.org/hoogle/ One stop shop for any help including keywords
* https://wiki.haskell.org/Keywords Description of all keywords
* https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
* https://hackage.haskell.org/package/base
* https://hackage.haskell.org/ All Haskell packages and their documentation

+----------+------------------------------------------------------------------+
| built-in | This is used to indicate functionality provided by GHC, the      |
|          | compiler                                                         |
+----------+------------------------------------------------------------------+
| packages | Libraries or modules live in packages, which need to be installed|
+----------+------------------------------------------------------------------+
| base     | `base` is a package providing basic and essential functionality  |
+----------+------------------------------------------------------------------+
| Prelude  | A module from `base` package which is automatically imported     |
+----------+------------------------------------------------------------------+

* Its a good idea to get familiar with Prelude and then other modules in the
  base package after you are familiar with the basic syntax.

Filenames
---------

+-----------+------------------+
| Extension | Meaning          |
+-----------+------------------+
| .hs       | Haskell          |
+-----------+------------------+
| .lhs      | Literate Haskell |
+-----------+------------------+

Importing Modules
-----------------

Data Types
----------

Basic Data Types (Prelude)
~~~~~~~~~~~~~~~~~~~~~~~~~~

+----------+------------------------------------------------------------------+
| Type     | Values                                                           |
+----------+----------+--------+------------+---------------------------------+
| Char     | 'a'      | 'b'    | 'c'        | Unicode character literals      |
+----------+----------+--------+------------+---------------------------------+
| Int      | -1       | 0      | 1          | Signed, Min: 2^63, Max: 2^63 - 1|
+----------+----------+--------+------------+---------------------------------+
| Word     | 0        | 1      | 2          | Unsigned, Min: 0, Max 2^64 - 1  |
+----------+----------+--------+------------+---------------------------------+
| Float    | -5.3     | 0.33333334          | Floating point                  |
+----------+----------+---------------------+---------------------------------+
| Double   | -5.3     | 0.3333333333333333  | Double precision floating point |
+----------+----------+---------------------+---------------------------------+

Basic Algebraic Data Types (Prelude)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* TODO: provide links to the definitions in base

+----------+----------+----------+------------+-------------------------------+
| ()       | ()       |          |            | Void value or empty tuple     |
+----------+----------+----------+------------+-------------------------------+
| (a, b)   | (1, 'a') | (0.3, 1) | (1, 2)     | Tuple of mixed types          |
+----------+----------+----------+------------+-------------------------------+
| [a]      | []       | 1 : []   | 1 : 2 : [] | List of Int                   |
|          |          |          |            | Explicit constructor syntax   |
|          +----------+----------+------------+-------------------------------+
|          | []       | [1]      | [1,2]      | Sugared syntax                |
|          +----------+----------+------------+-------------------------------+
|          | []       | ['a']    | ['a','b']  | List of chars (String)        |
|          +----------+----------+------------+-------------------------------+
|          | ""       | "a"      | "ab"       | String literals               |
+----------+----------+----------+------------+-------------------------------+
| Ordering | LT       | EQ       | GT         |                               |
+----------+----------+----------+------------+-------------------------------+
| Bool     | True     | False    |            |                               |
+----------+----------+----------+------------+-------------------------------+

Type Signatures
~~~~~~~~~~~~~~~

+--------+-------------------------------------------------------------------+
| ``::`` | Specifies type of a function or expression. Read it as `has type` |
+--------+-------------------------------------------------------------------+

::

  v :: Int
  v = 10

  f :: Int -> Int
  f a = a + 10

  f :: Int -> Int -> Int
  f a b = a + b + 10

Type of Expression
~~~~~~~~~~~~~~~~~~

* Expression or subexpression

::

  v = 10 :: Int

Defining New Data Types
~~~~~~~~~~~~~~~~~~~~~~~

::

  data Pair   = Pair Int Int deriving (Show, Eq)       -- Product
  data RPair  = RPair { first :: Int, second :: Int }  -- Record
  data Color  = Red | Green                            -- Sum
  data List a = Empty | Cons a (List a)                -- Recursive

Constructing Data
~~~~~~~~~~~~~~~~~

+---------------------------------------------------+
| ::                                                |
|                                                   |
|   let pair  = Pair 10 20                          |
|   let pair  = RPair 10 20                         |
|   let pair  = RPair {first=10, second=20}         |
|   let color = Red                                 |
|   let list  = Cons 10 (Cons 20 Empty) :: List Int |
+---------------------------------------------------+

Deconstructing Data by Pattern Match
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* All pattern matches (function, let, where) can be expressed in terms of `case`
* pattern matches on sum types can fail if we have not covered all possibilities
* ignore value with _
* as pattern

Decomposing Product Types
^^^^^^^^^^^^^^^^^^^^^^^^^

+--------------------------------------------------+
| ::                                               |
|                                                  |
|   let pair = Pair 10 20                          |
+----------------------+---------------------------+
| Case                 | Function                  |
+----------------------+---------------------------+
| ::                   | ::                        |
|                      |                           |
|  case pair of        |  total (Pair a b) = a + b |
|    Pair a b -> a + b |                           |
+----------------------+---------------------------+
| Let                  | Where                     |
+----------------------+---------------------------+
| ::                   | ::                        |
|                      |                           |
|  let Pair a b = pair |  total = a + b            |
|  in a + b            |   where Pair a b = pair   |
+----------------------+---------------------------+

Selecting Sum Types
^^^^^^^^^^^^^^^^^^^

+------------------------------------------------------------------+
| ::                                                               |
|                                                                  |
|  let color = Red                                                 |
+--------------------------------+---------------------------------+
| Case                           | Function                        |
+--------------------------------+---------------------------------+
| ::                             | ::                              |
|                                |                                 |
|  case color of                 |  name Red   = "red"             |
|    Red   -> "red"              |  name Green = "green"           |
|    Green -> "green"            |                                 |
|                                |                                 |
+--------------------------------+---------------------------------+
| Let                            | Where                           |
+--------------------------------+---------------------------------+
| ::                             | ::                              |
|                                |                                 |
|  let Red   = color in "red"    |  where Red   = color in "red"   |
|  -- pattern match will fail    |  -- pattern match will fail     |
|  let Green = color in "green"  |  where Green = color in "green" |
+--------------------------------+---------------------------------+

Expressing Conditions
^^^^^^^^^^^^^^^^^^^^^

* if and guards

Type Synonyms
^^^^^^^^^^^^^

newtype
^^^^^^^

Functions
---------

Function Application (built-in)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-----------------------------------------------------------------------------+
| `Space` is highest precedence and right associative function application    |
+-----------------------------------------------------------------------------+
| f x                                                                         |
+---------+-------------------------------------------------------------------+
| f x y   | (f x) y                                                           |
+---------+-------------------------------------------------------------------+
| f x y z | ((f x) y) z                                                       |
+---------+-------------------------------------------------------------------+

Function Application (Prelude)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-----------------------------------------------------------------------------+
| * $ is just opposite of space i.e. lowest precedence and left associative.  |
| * Think evaluating everything after a $ before applying it to the function  |
|   before it.                                                                |
+-------------+---------------------------------------------------------------+
| f $ x       | f x                                                           |
+-------------+---------------------------------------------------------------+
| f $ g x     | f (g x)                                                       |
+-------------+---------------------------------------------------------------+
| f $ g $ h x | f (g (h x))                                                   |
+-------------+---------------------------------------------------------------+

+-----------------------------------------------------------------------------+
| & is reverse function application                                           |
+-----------+-----------------------------------------------------------------+
| x & f     | f x                                                             |
+-----------+-----------------------------------------------------------------+
| x & g & f | f (g x)                                                         |
+-----------+-----------------------------------------------------------------+

+-----------------------------------------------------------------------------+
| swap the arguments before applying                                          |
+--------------+--------------------------------------------------------------+
| flip f $ x y | f y x                                                        |
+--------------+--------------------------------------------------------------+

Function Composition (Prelude)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-----------------------------------------------------------------------------+
| * ``.`` is composition, lower precedence than function application and      |
|   higher precedence than ``$``.                                             |
| * Note ``(f . g . h)`` applies ``h`` to the argument and then feeds the     |
|   result to ``g`` which feeds the result to ``f``.                          |
+-------------------+---------------------------------------------------------+
| (f . g) x         | f (g x)                                                 |
+-------------------+---------------------------------------------------------+
| f . g $ x         | (f . g) x                                               |
+-------------------+---------------------------------------------------------+
| (f . g . h) x     | f $ g $ h x                                             |
+-------------------+---------------------------------------------------------+
| f . g x           | f . (g x)                                               |
+-------------------+---------------------------------------------------------+

Infix and operator function (built-in)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

+-------------+---------------+
| Function    | Operator      |
+-------------+---------------+
| ``(+) 4 3`` | ``4 + 3``     |
+-------------+---------------+
| ``div 4 3`` | ``4 `div` 3`` |
+-------------+---------------+

* List of operators

Defining Functions
~~~~~~~~~~~~~~~~~~

* ignore value with _
* Equations / regular def
* let, where
* lambda

Defining Modules
----------------

module declaration: module X where ...

Common Prelude Functions
------------------------

Arithmatic
~~~~~~~~~~

* Defined in base

TODO: show the result of the expression

+-----------+-------------+-------------------------+
| Operation | Example     | Description             |
+-----------+-------------+-------------------------+
| \+        | 3 + 2       | Addition                |
+-----------+-------------+-------------------------+
| \-        | 3 - 2       | Subtraction             |
+-----------+-------------+-------------------------+
| \*        | 3 * 2       | Multiplication          |
+-----------+-------------+-------------------------+
| /         | 3 / 2       | Fractional division     |
+-----------+-------------+-------------------------+

+--------+----------------+---------------------------------------------------+
| ^      | 3 ^ 2          | Positive integer power                            |
+--------+----------------+---------------------------------------------------+
| ^^     | 3 ^^ 2         | Integer power                                     |
+--------+----------------+---------------------------------------------------+
| \**    | 3 \** 2.2      | Floating power                                    |
+--------+----------------+---------------------------------------------------+
| div    | 3 \`div\` (-2) | Integral division truncated toward -infinity      |
+--------+----------------+---------------------------------------------------+
| mod    | 3 \`mod\` (-2) | modulus of `div`                                  |
+--------+----------------+---------------------------------------------------+
| quot   | 3 \`div\` (-2) | Integral division quotient truncated towards zero |
+--------+----------------+---------------------------------------------------+
| rem    | 3 \`div\` (-2) | remainder of `quot`                               |
+--------+----------------+---------------------------------------------------+

Comparisons
~~~~~~~~~~~

+-----------+-------------+-------------------------+
| ==        | 3 == 2      |  Equals                 |
+-----------+-------------+-------------------------+
| /=        | 3 /= 2      |  Not equal              |
+-----------+-------------+-------------------------+
| >         | 3 >  2      |  Greater than           |
+-----------+-------------+-------------------------+
| >=        | 3 >= 2      |  Greater than or equal  |
+-----------+-------------+-------------------------+
| <         | 3 <  2      |  Less than              |
+-----------+-------------+-------------------------+
| <=        | 3 <= 2      |  Less than or equal     |
+-----------+-------------+-------------------------+

Boolean Logic
~~~~~~~~~~~~~

+-----------+---------------+-------------------------+
| Operation | Example       | Remarks                 |
+-----------+---------------+-------------------------+
| ||        | True || False |                         |
+-----------+---------------+-------------------------+
| &&        | True && False |                         |
+-----------+---------------+-------------------------+
| ==        | True == False |                         |
+-----------+---------------+-------------------------+
| /=        | True /= False |                         |
+-----------+---------------+-------------------------+
| not       | not True      |                         |
+-----------+---------------+-------------------------+

Lists
~~~~~

* See prelude

References
----------

