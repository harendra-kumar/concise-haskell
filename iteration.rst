Infinite Iterative Structures
=============================

We will study three lazy, infinite structures generated by iterating on:

* concrete values
* functions
* higher order functions

The first one is just a trivial case, the second one represents trivial
iteration , not very useful, while the third one uses iteration in the most
useful manner.

Iteration and Fix Point
-----------------------

Iteration is defined as applying a function repeatedly to its previous result.
As an example, we can apply `sqrt` to a number iteratively::

  takeWhile (/= 1) $ iterate sqrt 2

`sqrt` converges to 1 if we keep iterating it on any number. 1 is called the
fix-point of sqrt. In general when `c = f c`, `c` is called the fix point of a
function.

In the next few sections we will investigate how to iterate explicitly using
recursion.

Infinite Loop
-------------

The simplest recursive definition is recursion on concrete values::

  x = x

This is trivial recursion. `x` cannot be evaluated because determining it
requires it to be known i.e. it has a dependency on itself. Ever heard of the
chicken and egg problem?

Semantically, the value of `x` (i.e. a value that cannot be determined) is
denoted by a special notion called `bottom`.

Operationally, `x` is represented by an unevaluated closure that points to
itself.  Therefore when we evaluate `x` we get into an infinite loop.

TBD: verify this by looking at stg

Infinite Iteration
------------------

Let us create a bit more interesting recursive definition that iterates using a
function::

  x = f x

Operationally, the evaluation steps for this expression can be depicted as an
infinite iteration over the function `f`::

  f x
  f (f x)
  f (f (f x))
  ...

Unlike our trivial case in the previous section, the evaluation of `x` may or
may not terminate depending on how `f` is defined. Let us examine some
interesting cases.

When `f` discards its argument i.e. `f` does not depend on `x`, it terminates
trivially.  For example, when f is defined as `f x = 10` or equivalently `f =
const 10`.

On the other hand, if the function `f` depends on `x`, then `f x`, and
therefore `x`, cannot be determined without knowing `x` itself first; it is a
chicken and egg problem, and the evaluation of `x` never terminates. The
simplest example is `f = id`. The result of evaluation is bottom i.e.
non-termination.

Infinite Functions
------------------

As we saw in the previous section, our iteration using functions on concrete
values is not much interesting. We need to raise the level of abstraction.  What
if the `x` in `x = f x` is a function instead? Let's call it `g`, and having the
type `g :: a -> b`. Then f must be of type `f :: (a -> b) -> (a -> b)`; that
makes `f` a higher order function, and our iteration now becomes::

  g = f g

The value of this expression is an infinite function `g` which represents a
series of iterations of `f` over the initial value of `g`. Each iteration is a
new function generated by applying `f` to the previous function in the series.

Termination
~~~~~~~~~~~

The iteration over the higher order function never terminates but the
infinite function generated by this iteration can.

So, how is this useful if this does not terminate? The trick is that each
iteration produces a modified function. We can encode the termination
condition in the generated function so that iteration stops. Consider the
following definition of `f`::

  f g = h
    where
      h x -> case (sqrt x == x) of
        True -> x
        False -> g (sqrt x)

`h` is the function produced by `f`.  Notice that `h` does not use `g`
conditional on its argument `x`.  When `h` is passed the "right" value as
argument it stops the iteration and produces a value.  In other words, `g = f
g` can be determined because a function produced by `f g` is not dependent
on the unknown value `g`, no chicken and egg problem any more.

`f` is a wrapper function which wraps `g` to take `sqrt` of its argument and
terminate if it is the same as the argument else pass it on to the next
iteration.

Now we can try evaluating `g`::

  >> g 10
  1.0

Note that we could determine the value of expression `g = f g` here because it
not only depends on `g` but also on the argument that is passed to the
resulting function, `f g`, produced by the iteration. As we can see, `f` is
defined in terms of the function `g` as well as the argument of `f g`. In other
words, `f` is conditionally strict on `g`, when the condition is met the self
dependency is broken and the iteration stops.

Each lazy evaluation step of `g` either generates a new application of `f` or
terminates.

Alternate Definition
~~~~~~~~~~~~~~~~~~~~

The higher order function `f` shown above can also be written as::

  f g x =
      case (sqrt x == x) of
        True -> x
        False -> g (sqrt x)

From this definition, it is obvious that `f` not only uses `g` but also the
argument of the output function `f g`, which is `x`, in its definition. When we
pass `g` to `f` it will return us a function which takes one argument `x` and
is defined in terms of that argument.

Note that depending on how `f` is defined in terms of `g` and `x`, the
stop condition may never be met and the iteration may never stop.

Fix
---

If we generalize the type of `f` so that we can include functions having any number
of parameters then we get::

  f :: (a -> a)

We can write a utility function to iterate on a higher order function `f`, we
will call it `fix`::

  fix :: (a -> a) -> a
  fix f = let x = f x in x

Note that this is generally useful only when `a` is a function type as we
discussed previously. Therefore, `f` is usually a higher order function and
`fix f` returns a function.

This really generates an iterative version of a recursive function using lazy
evaluation. Each iteration generates a closure on the heap rather than a stack
frame on the stack as in the case of recursion. We can, in fact, write a
recursive version of the function we wrote in the previous section::

  sqrtFix x = if sqrt x == x then x else sqrtFix (sqrt x)

TBD: Compare stack and heap for recursion and iteration cases graphically.

The Y-Combinator
~~~~~~~~~~~~~~~~

fix is also called the fixed-point combinator or the Y combinator in lambda
calculus discovered by Haskell B. Curry::

  fix f = f (fix f)                -- Lambda lifted
  fix f = let x = f x in x         -- Lambda dropped

A Generic Fixer
~~~~~~~~~~~~~~~

We can write a generic wrapper function to find the fixed point of any single
argument function::

  fixer g h x =
      case (g x == x) of
        True -> x
        False -> h (g x)

  >> fix (fixer sqrt) 2
  1.0
  >> fix (fixer cos) 2
  0.7390851332151607

The function `fix` is a misnomer, it does not really find a fixed point of a
function it really only iterates, and you could have any condition to stop the
iteration not just the fixed point of a function. A more apt name for it will
perhaps be iterate. The function `fixer` is more like the one which generates
an iterator with a condition to find the fixed point of a function.

Using direct recursion::

  fixit g x =
      case (g x == x) of
        True -> x
        False -> fixit g (g x)

  >> fixit sqrt 2
  1.0
  >> fixit cos 2
  0.7390851332151607

References
----------

* Recursion, traversal & folds are related
* https://en.wikipedia.org/wiki/Fixed-point_combinator

* https://en.wikipedia.org/wiki/Primitive_recursive_function
* https://en.wikipedia.org/wiki/Recursion_(computer_science)
* https://en.wikipedia.org/wiki/Corecursion

Folds with recursion:

* https://en.wikipedia.org/wiki/Catamorphism generalizations of folds of lists to arbitrary algebraic data types
* https://en.wikipedia.org/wiki/Anamorphism Dual of catamorphism - unfold
* https://en.wikipedia.org/wiki/Paramorphism extension of catamorphism “eats its argument and keeps it too”
* https://en.wikipedia.org/wiki/Apomorphism Dual of paramorphsim
* https://en.wikipedia.org/wiki/Hylomorphism_(computer_science) anamorphism followed by a catamorphism

* https://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/
* https://ulissesaraujo.wordpress.com/2009/04/09/more-hylomorphisms-in-haskell/

* http://cgi.csc.liv.ac.uk/~grant/PS/thesis.pdf Algebraic Data Types and Program Transformation
* http://dl.acm.org/citation.cfm?id=2034807 A hierarchy of mendler style recursion combinators: taming inductive datatypes with negative occurrences".
